# DYNAMIC PRICING & YIELD MANAGEMENT
## Complete Technical Specification
**Feature:** Privacy-First Revenue Optimization  
**Project:** insane.marketing  
**Version:** 1.0 MVP  
**Date:** November 14, 2025

---

## üéØ PRODUCT OVERVIEW

**What it does:**
Analyzes anonymous aggregate data + external factors to provide real-time pricing recommendations that maximize venue revenue without storing any personal guest information.

**Core Value Proposition:**
*"Increase revenue 15-25% using AI-powered insights - while protecting 100% of guest privacy"*

**Privacy Promise:**
- Zero personal data collected
- Zero individual tracking
- 100% GDPR compliant
- Pure aggregate analytics

---

## üìä DATABASE SCHEMA

### **Table 1: demand_snapshots**
Stores anonymous demand patterns at regular intervals

```sql
CREATE TABLE demand_snapshots (
  id SERIAL PRIMARY KEY,
  restaurant_id VARCHAR(100) NOT NULL,
  snapshot_time TIMESTAMP NOT NULL,
  
  -- Anonymous Activity Metrics
  total_active_sessions INTEGER DEFAULT 0,
  total_scans_last_hour INTEGER DEFAULT 0,
  total_scans_last_24h INTEGER DEFAULT 0,
  active_tables_count INTEGER DEFAULT 0,
  
  -- Calculated Demand Score (0-100)
  demand_score DECIMAL(5,2) NOT NULL,
  demand_trend VARCHAR(20), -- 'increasing', 'stable', 'decreasing'
  confidence_level DECIMAL(5,2), -- 0.00-1.00
  
  -- External Factors (JSON)
  external_factors JSONB DEFAULT '{}'::jsonb,
  /* Example structure:
  {
    "weather": {
      "temp": 22,
      "condition": "sunny",
      "precipitation": 0,
      "impact_score": 0.8
    },
    "events": [
      {
        "name": "Chelsea vs Arsenal",
        "distance_km": 0.8,
        "start_time": "2025-11-16T15:00:00Z",
        "impact_score": 0.9
      }
    ],
    "is_holiday": false,
    "day_of_week": "Saturday",
    "special_factors": []
  }
  */
  
  created_at TIMESTAMP DEFAULT NOW(),
  
  FOREIGN KEY (restaurant_id) REFERENCES restaurants(restaurant_id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_demand_restaurant_time 
  ON demand_snapshots(restaurant_id, snapshot_time DESC);
  
CREATE INDEX idx_demand_score 
  ON demand_snapshots(restaurant_id, demand_score DESC);
```

---

### **Table 2: pricing_recommendations**
Stores AI-generated pricing suggestions

```sql
CREATE TABLE pricing_recommendations (
  id SERIAL PRIMARY KEY,
  restaurant_id VARCHAR(100) NOT NULL,
  recommendation_id VARCHAR(100) UNIQUE NOT NULL, -- e.g., "rec_2025-11-16_001"
  recommendation_time TIMESTAMP NOT NULL,
  
  -- Demand Context
  demand_score DECIMAL(5,2) NOT NULL,
  demand_snapshot_id INTEGER,
  
  -- Recommendations (JSON Array)
  suggested_adjustments JSONB NOT NULL,
  /* Example structure:
  [
    {
      "zone": "VIP Tables",
      "current_modifier": 1.0,
      "suggested_modifier": 1.25,
      "adjustment_pct": 25,
      "confidence": 0.92,
      "reasoning": "High demand: Chelsea match + sunny weather",
      "expected_revenue_impact": 1200
    },
    {
      "zone": "Early Dining",
      "current_modifier": 1.0,
      "suggested_modifier": 0.90,
      "adjustment_pct": -10,
      "confidence": 0.78,
      "reasoning": "Fill capacity during low-demand period",
      "expected_revenue_impact": 450
    }
  ]
  */
  
  -- Impact Predictions
  total_expected_impact DECIMAL(10,2), -- Total ¬£ revenue impact
  expected_demand_change DECIMAL(5,2), -- % change in bookings expected
  
  -- Application Tracking
  applied BOOLEAN DEFAULT FALSE,
  applied_at TIMESTAMP,
  applied_by VARCHAR(100), -- User who applied it
  
  -- Actual Results (filled in later)
  actual_revenue_impact DECIMAL(10,2),
  actual_demand_change DECIMAL(5,2),
  accuracy_score DECIMAL(5,2), -- How accurate was prediction
  
  -- Metadata
  recommendation_type VARCHAR(50) DEFAULT 'ai_generated', -- or 'manual', 'override'
  expires_at TIMESTAMP, -- Recommendations are time-sensitive
  created_at TIMESTAMP DEFAULT NOW(),
  
  FOREIGN KEY (restaurant_id) REFERENCES restaurants(restaurant_id) ON DELETE CASCADE,
  FOREIGN KEY (demand_snapshot_id) REFERENCES demand_snapshots(id) ON DELETE SET NULL
);

-- Indexes
CREATE INDEX idx_pricing_restaurant_time 
  ON pricing_recommendations(restaurant_id, recommendation_time DESC);
  
CREATE INDEX idx_pricing_applied 
  ON pricing_recommendations(restaurant_id, applied, created_at DESC);
```

---

### **Table 3: revenue_snapshots**
Tracks aggregate revenue metrics for ML training and impact measurement

```sql
CREATE TABLE revenue_snapshots (
  id SERIAL PRIMARY KEY,
  restaurant_id VARCHAR(100) NOT NULL,
  
  -- Time Period
  snapshot_date DATE NOT NULL,
  snapshot_hour INTEGER, -- 0-23, NULL for daily aggregates
  
  -- Aggregate Revenue Metrics (NO PERSONAL DATA)
  total_revenue DECIMAL(10,2) DEFAULT 0,
  total_covers INTEGER DEFAULT 0, -- Number of guests served
  average_spend_per_cover DECIMAL(10,2),
  
  -- Occupancy Metrics
  total_capacity INTEGER, -- Total seats/tables
  occupied_capacity INTEGER, -- How many were used
  occupancy_rate DECIMAL(5,2), -- % full
  
  -- Service Metrics (Anonymous)
  total_service_requests INTEGER DEFAULT 0,
  avg_service_response_time INTEGER, -- Seconds
  
  -- Pricing Context
  active_pricing_modifier DECIMAL(5,2) DEFAULT 1.0, -- What multiplier was active
  
  -- Metadata
  data_quality VARCHAR(20) DEFAULT 'complete', -- 'complete', 'partial', 'estimated'
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  FOREIGN KEY (restaurant_id) REFERENCES restaurants(restaurant_id) ON DELETE CASCADE,
  
  -- Ensure no duplicate snapshots
  UNIQUE(restaurant_id, snapshot_date, snapshot_hour)
);

-- Indexes
CREATE INDEX idx_revenue_restaurant_date 
  ON revenue_snapshots(restaurant_id, snapshot_date DESC);
  
CREATE INDEX idx_revenue_occupancy 
  ON revenue_snapshots(restaurant_id, occupancy_rate DESC);
```

---

### **Table 4: external_events**
Cache of external events affecting demand (concerts, sports, conferences)

```sql
CREATE TABLE external_events (
  id SERIAL PRIMARY KEY,
  
  -- Event Details
  event_name VARCHAR(255) NOT NULL,
  event_type VARCHAR(50), -- 'sports', 'concert', 'conference', 'holiday'
  event_date DATE NOT NULL,
  event_time TIME,
  
  -- Location
  venue_name VARCHAR(255),
  latitude DECIMAL(10,7),
  longitude DECIMAL(10,7),
  city VARCHAR(100),
  
  -- Impact Metrics
  expected_attendance INTEGER,
  impact_radius_km DECIMAL(5,2) DEFAULT 2.0, -- How far impact extends
  
  -- Data Source
  source VARCHAR(100), -- 'ticketmaster', 'eventbrite', 'manual', etc.
  source_id VARCHAR(255), -- External API ID
  
  -- Metadata
  fetched_at TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  
  -- Prevent duplicates
  UNIQUE(source, source_id)
);

-- Indexes for proximity searches
CREATE INDEX idx_events_date 
  ON external_events(event_date, event_time);
  
CREATE INDEX idx_events_location 
  ON external_events(city, event_date);
```

---

## üîß BACKEND API ENDPOINTS

### **Endpoint 1: Get Current Demand**
```
GET /api/pricing/demand/:restaurantId
```

**Purpose:** Returns real-time demand analysis

**Response:**
```json
{
  "success": true,
  "restaurant_id": "chelseahotel",
  "timestamp": "2025-11-16T14:30:00Z",
  "demand": {
    "score": 78,
    "level": "high",
    "trend": "increasing",
    "confidence": 0.89,
    "change_24h": 25
  },
  "metrics": {
    "active_sessions": 45,
    "scans_last_hour": 120,
    "occupancy_rate": 72
  },
  "external_factors": {
    "weather": {
      "condition": "sunny",
      "temp": 22,
      "impact": "positive"
    },
    "upcoming_events": [
      {
        "name": "Chelsea vs Arsenal",
        "distance": "0.8km",
        "time": "15:00",
        "impact": "very_high"
      }
    ]
  }
}
```

**Implementation:**
```javascript
// In server.js
app.get('/api/pricing/demand/:restaurantId', authenticateToken, async (req, res) => {
  try {
    const { restaurantId } = req.params;
    
    // Get current activity (anonymous aggregates)
    const currentActivity = await getCurrentActivity(restaurantId);
    
    // Get historical baseline
    const historicalAvg = await getHistoricalAverage(restaurantId);
    
    // Get external factors
    const externalFactors = await getExternalFactors(restaurantId);
    
    // Calculate demand score
    const demandScore = calculateDemandScore({
      current: currentActivity,
      historical: historicalAvg,
      external: externalFactors
    });
    
    // Store snapshot
    await pool.query(`
      INSERT INTO demand_snapshots (
        restaurant_id, snapshot_time, total_active_sessions, 
        total_scans_last_hour, demand_score, demand_trend, 
        confidence_level, external_factors
      ) VALUES ($1, NOW(), $2, $3, $4, $5, $6, $7)
    `, [
      restaurantId,
      currentActivity.sessions,
      currentActivity.scans,
      demandScore.score,
      demandScore.trend,
      demandScore.confidence,
      JSON.stringify(externalFactors)
    ]);
    
    res.json({
      success: true,
      restaurant_id: restaurantId,
      timestamp: new Date().toISOString(),
      demand: demandScore,
      metrics: currentActivity,
      external_factors: externalFactors
    });
    
  } catch (error) {
    console.error('Demand analysis error:', error);
    res.status(500).json({ error: 'Failed to analyze demand' });
  }
});

// Helper function: Get current activity
async function getCurrentActivity(restaurantId) {
  const result = await pool.query(`
    SELECT 
      COUNT(DISTINCT session_id) as active_sessions,
      COUNT(*) as total_scans
    FROM qr_scans
    WHERE restaurant_id = $1 
      AND scan_timestamp > NOW() - INTERVAL '1 hour'
  `, [restaurantId]);
  
  const sessionResult = await pool.query(`
    SELECT COUNT(*) as active_count
    FROM table_sessions
    WHERE restaurant_id = $1 
      AND status = 'active'
  `, [restaurantId]);
  
  return {
    sessions: parseInt(result.rows[0].active_sessions) || 0,
    scans: parseInt(result.rows[0].total_scans) || 0,
    active_tables: parseInt(sessionResult.rows[0].active_count) || 0
  };
}

// Helper function: Get historical average
async function getHistoricalAverage(restaurantId) {
  const dayOfWeek = new Date().getDay();
  const currentHour = new Date().getHours();
  
  const result = await pool.query(`
    SELECT 
      AVG(total_scans_last_hour) as avg_scans,
      AVG(total_active_sessions) as avg_sessions
    FROM demand_snapshots
    WHERE restaurant_id = $1
      AND EXTRACT(DOW FROM snapshot_time) = $2
      AND EXTRACT(HOUR FROM snapshot_time) = $3
      AND snapshot_time > NOW() - INTERVAL '90 days'
  `, [restaurantId, dayOfWeek, currentHour]);
  
  return {
    avg_scans: parseFloat(result.rows[0]?.avg_scans) || 50,
    avg_sessions: parseFloat(result.rows[0]?.avg_sessions) || 20
  };
}

// Helper function: Calculate demand score
function calculateDemandScore({ current, historical, external }) {
  // Base score from current vs historical
  const scanRatio = current.scans / Math.max(historical.avg_scans, 1);
  const sessionRatio = current.sessions / Math.max(historical.avg_sessions, 1);
  
  let baseScore = ((scanRatio + sessionRatio) / 2) * 50; // 0-100 scale
  
  // Apply external factor multipliers
  if (external.weather?.impact === 'positive') baseScore *= 1.1;
  if (external.weather?.impact === 'negative') baseScore *= 0.9;
  
  if (external.events?.length > 0) {
    const maxEventImpact = Math.max(...external.events.map(e => e.impact_score || 0));
    baseScore *= (1 + maxEventImpact * 0.3); // Up to 30% boost
  }
  
  // Normalize to 0-100
  const finalScore = Math.min(Math.max(baseScore, 0), 100);
  
  // Determine trend
  let trend = 'stable';
  if (scanRatio > 1.2) trend = 'increasing';
  if (scanRatio < 0.8) trend = 'decreasing';
  
  // Confidence based on data quality
  const confidence = Math.min(
    current.scans > 10 ? 0.9 : 0.6,
    historical.avg_scans > 0 ? 1.0 : 0.5
  );
  
  return {
    score: Math.round(finalScore * 100) / 100,
    level: finalScore > 70 ? 'high' : finalScore > 40 ? 'medium' : 'low',
    trend,
    confidence: Math.round(confidence * 100) / 100,
    change_24h: Math.round((scanRatio - 1) * 100)
  };
}
```

---

### **Endpoint 2: Get Pricing Recommendations**
```
GET /api/pricing/recommendations/:restaurantId
```

**Purpose:** AI-generated pricing suggestions based on current conditions

**Response:**
```json
{
  "success": true,
  "restaurant_id": "chelseahotel",
  "timestamp": "2025-11-16T14:30:00Z",
  "demand_context": {
    "score": 78,
    "level": "high"
  },
  "recommendations": [
    {
      "zone": "VIP Tables",
      "current_modifier": 1.0,
      "suggested_modifier": 1.25,
      "adjustment_pct": 25,
      "confidence": 0.92,
      "reasoning": "High demand detected: Chelsea match (3pm) + sunny weather. VIP tables typically overbooked on match days.",
      "expected_revenue_impact": 1200,
      "recommendation_id": "rec_2025-11-16_001",
      "priority": "high",
      "expires_at": "2025-11-16T22:00:00Z"
    },
    {
      "zone": "Early Dining (5-7pm)",
      "current_modifier": 1.0,
      "suggested_modifier": 0.90,
      "adjustment_pct": -10,
      "confidence": 0.78,
      "reasoning": "Fill capacity during pre-match low-demand window. Attract early diners.",
      "expected_revenue_impact": 450,
      "recommendation_id": "rec_2025-11-16_002",
      "priority": "medium",
      "expires_at": "2025-11-16T17:00:00Z"
    }
  ],
  "total_expected_impact": 1650,
  "recommendation_summary": "Apply surge pricing on VIP tables, discount early dining to optimize overall revenue"
}
```

**Implementation:**
```javascript
app.get('/api/pricing/recommendations/:restaurantId', authenticateToken, async (req, res) => {
  try {
    const { restaurantId } = req.params;
    
    // Get latest demand analysis
    const demand = await getDemandAnalysis(restaurantId);
    
    // Generate recommendations
    const recommendations = await generateRecommendations(restaurantId, demand);
    
    // Store recommendations
    const recommendationId = `rec_${new Date().toISOString().split('T')[0]}_${Date.now()}`;
    
    await pool.query(`
      INSERT INTO pricing_recommendations (
        restaurant_id, recommendation_id, recommendation_time,
        demand_score, suggested_adjustments, total_expected_impact,
        expected_demand_change, expires_at
      ) VALUES ($1, $2, NOW(), $3, $4, $5, $6, NOW() + INTERVAL '6 hours')
    `, [
      restaurantId,
      recommendationId,
      demand.score,
      JSON.stringify(recommendations),
      recommendations.reduce((sum, r) => sum + r.expected_revenue_impact, 0),
      0 // Will be calculated later
    ]);
    
    res.json({
      success: true,
      restaurant_id: restaurantId,
      timestamp: new Date().toISOString(),
      demand_context: demand,
      recommendations,
      total_expected_impact: recommendations.reduce((sum, r) => sum + r.expected_revenue_impact, 0)
    });
    
  } catch (error) {
    console.error('Recommendations error:', error);
    res.status(500).json({ error: 'Failed to generate recommendations' });
  }
});

// Generate pricing recommendations
async function generateRecommendations(restaurantId, demand) {
  const recommendations = [];
  
  // HIGH DEMAND SCENARIO
  if (demand.score > 70) {
    recommendations.push({
      zone: "VIP Tables",
      current_modifier: 1.0,
      suggested_modifier: 1.25,
      adjustment_pct: 25,
      confidence: 0.92,
      reasoning: `High demand detected (score: ${demand.score}). ${demand.external_factors?.events?.[0]?.name || 'Major local event'} + ${demand.external_factors?.weather?.condition || 'favorable weather'}.`,
      expected_revenue_impact: estimateImpact('vip', 0.25, demand),
      priority: "high",
      expires_at: new Date(Date.now() + 6 * 60 * 60 * 1000).toISOString()
    });
    
    recommendations.push({
      zone: "Standard Tables",
      current_modifier: 1.0,
      suggested_modifier: 1.10,
      adjustment_pct: 10,
      confidence: 0.85,
      reasoning: "Moderate increase on standard tables during peak demand",
      expected_revenue_impact: estimateImpact('standard', 0.10, demand),
      priority: "medium",
      expires_at: new Date(Date.now() + 6 * 60 * 60 * 1000).toISOString()
    });
  }
  
  // LOW DEMAND SCENARIO
  if (demand.score < 40) {
    recommendations.push({
      zone: "All Tables",
      current_modifier: 1.0,
      suggested_modifier: 0.85,
      adjustment_pct: -15,
      confidence: 0.80,
      reasoning: `Low demand period (score: ${demand.score}). Attract bookings with promotional pricing.`,
      expected_revenue_impact: estimateImpact('all', -0.15, demand),
      priority: "high",
      expires_at: new Date(Date.now() + 12 * 60 * 60 * 1000).toISOString()
    });
  }
  
  // TIME-BASED OPTIMIZATION (Always suggest)
  const currentHour = new Date().getHours();
  if (currentHour >= 17 && currentHour < 19) {
    recommendations.push({
      zone: "Early Dining (5-7pm)",
      current_modifier: 1.0,
      suggested_modifier: 0.90,
      adjustment_pct: -10,
      confidence: 0.75,
      reasoning: "Fill early dining capacity. Attract pre-theater/pre-event diners.",
      expected_revenue_impact: estimateImpact('early', -0.10, demand),
      priority: "medium",
      expires_at: new Date().setHours(19, 0, 0, 0)
    });
  }
  
  return recommendations;
}

// Estimate revenue impact
function estimateImpact(zone, modifier, demand) {
  // Simplified model - would be ML-based in production
  const baselineRevenue = {
    'vip': 5000,
    'standard': 3000,
    'all': 8000,
    'early': 1500
  };
  
  const base = baselineRevenue[zone] || 3000;
  const demandMultiplier = demand.score / 50; // Normalize around 1.0
  
  return Math.round(base * modifier * demandMultiplier);
}
```

---

### **Endpoint 3: Apply Recommendation**
```
POST /api/pricing/apply
```

**Purpose:** Record when venue applies a pricing recommendation

**Request Body:**
```json
{
  "recommendation_id": "rec_2025-11-16_001",
  "applied_by": "manager@chelseahotel.com"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Recommendation applied successfully",
  "recommendation_id": "rec_2025-11-16_001",
  "tracking_enabled": true
}
```

**Implementation:**
```javascript
app.post('/api/pricing/apply', authenticateToken, async (req, res) => {
  try {
    const { recommendation_id, applied_by } = req.body;
    
    await pool.query(`
      UPDATE pricing_recommendations
      SET applied = TRUE,
          applied_at = NOW(),
          applied_by = $2
      WHERE recommendation_id = $1
    `, [recommendation_id, applied_by]);
    
    res.json({
      success: true,
      message: 'Recommendation applied successfully',
      recommendation_id,
      tracking_enabled: true
    });
    
  } catch (error) {
    console.error('Apply recommendation error:', error);
    res.status(500).json({ error: 'Failed to apply recommendation' });
  }
});
```

---

### **Endpoint 4: Get Demand Forecast**
```
GET /api/pricing/forecast/:restaurantId?days=7
```

**Purpose:** Predict demand for next N days

**Response:**
```json
{
  "success": true,
  "restaurant_id": "chelseahotel",
  "forecast_period": {
    "start": "2025-11-17",
    "end": "2025-11-23",
    "days": 7
  },
  "daily_forecasts": [
    {
      "date": "2025-11-17",
      "day_of_week": "Monday",
      "predicted_demand": 45,
      "confidence": 0.82,
      "factors": ["Normal weekday", "No major events"],
      "recommendation": "Standard pricing"
    },
    {
      "date": "2025-11-23",
      "day_of_week": "Saturday",
      "predicted_demand": 88,
      "confidence": 0.91,
      "factors": ["Weekend", "Chelsea match 3pm", "Sunny forecast"],
      "recommendation": "Surge pricing recommended"
    }
  ]
}
```

---

### **Endpoint 5: Get Revenue Impact Report**
```
GET /api/pricing/impact/:restaurantId?period=month
```

**Purpose:** Show how pricing optimizations affected revenue

**Response:**
```json
{
  "success": true,
  "restaurant_id": "chelseahotel",
  "period": "month",
  "start_date": "2025-10-16",
  "end_date": "2025-11-16",
  "summary": {
    "total_recommendations": 42,
    "recommendations_applied": 28,
    "application_rate": 67,
    "total_revenue_impact": 12450,
    "average_accuracy": 89,
    "roi_multiplier": 24.9
  },
  "top_performers": [
    {
      "date": "2025-11-10",
      "recommendation": "VIP surge pricing",
      "predicted_impact": 1500,
      "actual_impact": 1680,
      "accuracy": 112
    }
  ]
}
```

---

## üå¶Ô∏è EXTERNAL DATA INTEGRATIONS

### **Weather API Integration**
```javascript
// Use OpenWeather API (free tier: 1000 calls/day)
async function getWeatherData(latitude, longitude) {
  const apiKey = process.env.OPENWEATHER_API_KEY;
  const url = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric`;
  
  try {
    const response = await fetch(url);
    const data = await response.json();
    
    return {
      temp: data.main.temp,
      condition: data.weather[0].main.toLowerCase(),
      precipitation: data.rain?.['1h'] || 0,
      impact: determineWeatherImpact(data)
    };
  } catch (error) {
    console.error('Weather API error:', error);
    return { temp: 20, condition: 'unknown', impact: 'neutral' };
  }
}

function determineWeatherImpact(weatherData) {
  const temp = weatherData.main.temp;
  const condition = weatherData.weather[0].main.toLowerCase();
  
  // Positive impact
  if (condition === 'clear' && temp >= 15 && temp <= 25) return 'positive';
  if (condition === 'clouds' && temp >= 10 && temp <= 20) return 'neutral';
  
  // Negative impact
  if (condition === 'rain' || condition === 'snow') return 'negative';
  if (temp < 5 || temp > 30) return 'negative';
  
  return 'neutral';
}
```

### **Events API Integration**
```javascript
// Use Ticketmaster API (free tier available)
async function getNearbyEvents(latitude, longitude, radiusKm = 5) {
  const apiKey = process.env.TICKETMASTER_API_KEY;
  const url = `https://app.ticketmaster.com/discovery/v2/events.json?apikey=${apiKey}&latlong=${latitude},${longitude}&radius=${radiusKm}&unit=km&size=10`;
  
  try {
    const response = await fetch(url);
    const data = await response.json();
    
    if (!data._embedded?.events) return [];
    
    return data._embedded.events.map(event => ({
      name: event.name,
      date: event.dates.start.localDate,
      time: event.dates.start.localTime,
      venue: event._embedded.venues[0].name,
      distance: calculateDistance(
        latitude, 
        longitude,
        event._embedded.venues[0].location.latitude,
        event._embedded.venues[0].location.longitude
      ),
      impact_score: estimateEventImpact(event)
    }));
  } catch (error) {
    console.error('Events API error:', error);
    return [];
  }
}

function estimateEventImpact(event) {
  // Higher impact for bigger events
  const classification = event.classifications?.[0];
  
  if (classification?.segment?.name === 'Sports') return 0.9;
  if (classification?.segment?.name === 'Music') return 0.8;
  if (classification?.segment?.name === 'Arts & Theatre') return 0.6;
  
  return 0.5;
}
```

---

## üé® FRONTEND IMPLEMENTATION

### **Mission Control - New Section**

**File:** Add to `welcome.html` or create new `revenue-optimization.html`

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Revenue Optimization - insane.marketing</title>
  <script src="config-client.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e293b, #334155);
      color: white;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .header {
      margin-bottom: 30px;
    }
    
    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }
    
    .header p {
      color: #94a3b8;
      font-size: 1.1rem;
    }
    
    /* Demand Meter Widget */
    .demand-meter {
      background: rgba(255,255,255,0.1);
      padding: 30px;
      border-radius: 16px;
      margin-bottom: 30px;
    }
    
    .demand-gauge {
      width: 100%;
      height: 40px;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      overflow: hidden;
      margin: 20px 0;
      position: relative;
    }
    
    .gauge-fill {
      height: 100%;
      background: linear-gradient(90deg, #10b981, #f59e0b, #ef4444);
      border-radius: 20px;
      transition: width 1s ease;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 15px;
      font-weight: bold;
    }
    
    .demand-label {
      font-size: 1.5rem;
      font-weight: bold;
      text-align: center;
      margin: 10px 0;
    }
    
    .demand-label.high { color: #ef4444; }
    .demand-label.medium { color: #f59e0b; }
    .demand-label.low { color: #10b981; }
    
    .demand-trend {
      text-align: center;
      font-size: 1.1rem;
      color: #94a3b8;
    }
    
    /* Recommendations Grid */
    .recommendations-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .recommendation-card {
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 25px;
      border-left: 4px solid #3b82f6;
      transition: all 0.3s;
    }
    
    .recommendation-card:hover {
      background: rgba(255,255,255,0.15);
      transform: translateY(-2px);
    }
    
    .recommendation-card.urgent {
      border-left-color: #ef4444;
      background: rgba(239,68,68,0.1);
    }
    
    .rec-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .rec-icon {
      font-size: 2rem;
    }
    
    .rec-zone {
      font-size: 1.3rem;
      font-weight: bold;
    }
    
    .rec-action {
      font-size: 1.4rem;
      font-weight: bold;
      color: #10b981;
      margin-bottom: 10px;
    }
    
    .rec-action.decrease {
      color: #3b82f6;
    }
    
    .rec-reason {
      color: #94a3b8;
      margin-bottom: 15px;
      line-height: 1.5;
    }
    
    .rec-impact {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
    }
    
    .impact-label {
      color: #94a3b8;
      font-size: 0.9rem;
    }
    
    .impact-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #10b981;
    }
    
    .apply-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .apply-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16,185,129,0.3);
    }
    
    .apply-btn:active {
      transform: translateY(0);
    }
    
    .apply-btn.applied {
      background: #6b7280;
      cursor: not-allowed;
    }
    
    /* Forecast Chart */
    .forecast-section {
      background: rgba(255,255,255,0.1);
      padding: 30px;
      border-radius: 16px;
      margin-bottom: 30px;
    }
    
    .forecast-chart {
      display: flex;
      justify-content: space-around;
      align-items: flex-end;
      height: 200px;
      margin-top: 20px;
      gap: 10px;
    }
    
    .forecast-day {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .demand-bar {
      width: 100%;
      background: linear-gradient(180deg, #3b82f6, #1e40af);
      border-radius: 8px 8px 0 0;
      min-height: 20px;
      position: relative;
      transition: height 0.5s ease;
    }
    
    .forecast-day.high .demand-bar {
      background: linear-gradient(180deg, #ef4444, #b91c1c);
    }
    
    .day-label {
      font-weight: bold;
      color: #94a3b8;
    }
    
    .demand-number {
      font-size: 0.9rem;
      color: #cbd5e1;
    }
    
    .event-tag {
      background: #ef4444;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.8rem;
      margin-top: 5px;
    }
    
    /* Impact Tracker */
    .impact-tracker {
      background: rgba(255,255,255,0.1);
      padding: 30px;
      border-radius: 16px;
    }
    
    .impact-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .stat {
      text-align: center;
      padding: 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
    }
    
    .stat-value {
      display: block;
      font-size: 2rem;
      font-weight: bold;
      color: #10b981;
      margin-bottom: 8px;
    }
    
    .stat-label {
      color: #94a3b8;
      font-size: 0.9rem;
    }
    
    /* Loading State */
    .loading {
      text-align: center;
      padding: 40px;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.1);
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üíé Revenue Optimization</h1>
      <p>AI-powered pricing intelligence ‚Ä¢ 100% privacy-safe</p>
    </div>
    
    <!-- Current Demand -->
    <div class="demand-meter">
      <h2>üìä Current Demand</h2>
      <div class="demand-gauge">
        <div class="gauge-fill" id="demand-gauge" style="width: 0%">
          <span id="demand-score">-</span>
        </div>
      </div>
      <p class="demand-label" id="demand-label">Loading...</p>
      <p class="demand-trend" id="demand-trend"></p>
    </div>
    
    <!-- Recommendations -->
    <div id="recommendations-container">
      <h2 style="margin-bottom: 20px;">üí° Smart Pricing Recommendations</h2>
      <div class="recommendations-grid" id="recommendations-grid">
        <div class="loading">
          <div class="spinner"></div>
          <p>Analyzing demand patterns...</p>
        </div>
      </div>
    </div>
    
    <!-- 7-Day Forecast -->
    <div class="forecast-section">
      <h2>üìÖ 7-Day Demand Forecast</h2>
      <div class="forecast-chart" id="forecast-chart">
        <!-- Will be populated by JavaScript -->
      </div>
    </div>
    
    <!-- Impact Tracker -->
    <div class="impact-tracker">
      <h2>üìà This Month's Impact</h2>
      <div class="impact-stats">
        <div class="stat">
          <span class="stat-value" id="total-impact">¬£0</span>
          <span class="stat-label">Additional Revenue</span>
        </div>
        <div class="stat">
          <span class="stat-value" id="accuracy">-%</span>
          <span class="stat-label">Prediction Accuracy</span>
        </div>
        <div class="stat">
          <span class="stat-value" id="applied-count">0</span>
          <span class="stat-label">Optimizations Applied</span>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // =====================================
    // INITIALIZATION
    // =====================================
    
    let restaurantId = null;
    let currentRecommendations = [];
    
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('üöÄ Initializing Revenue Optimization...');
      
      // Get authenticated user
      const user = CONFIG.getAuthenticatedUser();
      
      if (!user || !user.restaurantId) {
        console.error('No authenticated user found');
        window.location.href = '/login.html';
        return;
      }
      
      restaurantId = user.restaurantId;
      console.log('‚úÖ Restaurant ID:', restaurantId);
      
      // Load all data
      await loadDemandData();
      await loadRecommendations();
      await loadImpactMetrics();
      
      // Refresh every 2 minutes
      setInterval(async () => {
        await loadDemandData();
        await loadRecommendations();
      }, 120000);
    });
    
    // =====================================
    // LOAD DEMAND DATA
    // =====================================
    
    async function loadDemandData() {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await fetch(
          `${CONFIG.getApiBaseUrl()}/api/pricing/demand/${restaurantId}`,
          {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          }
        );
        
        if (!response.ok) throw new Error('Failed to load demand data');
        
        const data = await response.json();
        console.log('üìä Demand data loaded:', data);
        
        // Update UI
        updateDemandMeter(data.demand);
        
      } catch (error) {
        console.error('Error loading demand data:', error);
        showError('demand-meter', 'Failed to load demand data');
      }
    }
    
    function updateDemandMeter(demand) {
      const gauge = document.getElementById('demand-gauge');
      const scoreText = document.getElementById('demand-score');
      const label = document.getElementById('demand-label');
      const trend = document.getElementById('demand-trend');
      
      // Animate gauge
      setTimeout(() => {
        gauge.style.width = `${demand.score}%`;
        scoreText.textContent = Math.round(demand.score);
      }, 100);
      
      // Update label
      label.textContent = demand.level.toUpperCase() + ' DEMAND';
      label.className = 'demand-label ' + demand.level;
      
      // Update trend
      const trendIcon = demand.trend === 'increasing' ? '‚Üë' : 
                       demand.trend === 'decreasing' ? '‚Üì' : '‚Üí';
      const change = demand.change_24h > 0 ? `+${demand.change_24h}%` : `${demand.change_24h}%`;
      trend.textContent = `${trendIcon} ${change} vs yesterday`;
    }
    
    // =====================================
    // LOAD RECOMMENDATIONS
    // =====================================
    
    async function loadRecommendations() {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await fetch(
          `${CONFIG.getApiBaseUrl()}/api/pricing/recommendations/${restaurantId}`,
          {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          }
        );
        
        if (!response.ok) throw new Error('Failed to load recommendations');
        
        const data = await response.json();
        console.log('üí° Recommendations loaded:', data);
        
        currentRecommendations = data.recommendations || [];
        renderRecommendations(currentRecommendations);
        
      } catch (error) {
        console.error('Error loading recommendations:', error);
        showError('recommendations-grid', 'Failed to load recommendations');
      }
    }
    
    function renderRecommendations(recommendations) {
      const grid = document.getElementById('recommendations-grid');
      
      if (recommendations.length === 0) {
        grid.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #94a3b8;">
            <div style="font-size: 3rem; margin-bottom: 16px;">‚úÖ</div>
            <h3>All Optimized!</h3>
            <p>No pricing adjustments needed at this time.</p>
          </div>
        `;
        return;
      }
      
      grid.innerHTML = recommendations.map(rec => `
        <div class="recommendation-card ${rec.priority === 'high' ? 'urgent' : ''}">
          <div class="rec-header">
            <span class="rec-icon">${getPriorityIcon(rec.priority)}</span>
            <div>
              <div class="rec-zone">${rec.zone}</div>
              <div style="font-size: 0.9rem; color: #94a3b8;">
                Confidence: ${Math.round(rec.confidence * 100)}%
              </div>
            </div>
          </div>
          
          <p class="rec-action ${rec.adjustment_pct < 0 ? 'decrease' : ''}">
            ${rec.adjustment_pct > 0 ? '+' : ''}${rec.adjustment_pct}% 
            ${rec.adjustment_pct > 0 ? 'Increase' : 'Decrease'}
          </p>
          
          <p class="rec-reason">${rec.reasoning}</p>
          
          <div class="rec-impact">
            <div>
              <div class="impact-label">Expected Impact</div>
              <div class="impact-value">¬£${rec.expected_revenue_impact.toLocaleString()}</div>
            </div>
            <div style="text-align: right;">
              <div class="impact-label">Priority</div>
              <div class="impact-value" style="color: ${getPriorityColor(rec.priority)}">
                ${rec.priority.toUpperCase()}
              </div>
            </div>
          </div>
          
          <button class="apply-btn" onclick="applyRecommendation('${rec.recommendation_id}')">
            Apply Recommendation
          </button>
        </div>
      `).join('');
    }
    
    function getPriorityIcon(priority) {
      switch(priority) {
        case 'high': return 'üî•';
        case 'medium': return '‚ö°';
        case 'low': return 'üí°';
        default: return 'üìä';
      }
    }
    
    function getPriorityColor(priority) {
      switch(priority) {
        case 'high': return '#ef4444';
        case 'medium': return '#f59e0b';
        case 'low': return '#3b82f6';
        default: return '#94a3b8';
      }
    }
    
    // =====================================
    // APPLY RECOMMENDATION
    // =====================================
    
    async function applyRecommendation(recommendationId) {
      try {
        const token = localStorage.getItem('auth_token');
        const user = CONFIG.getAuthenticatedUser();
        
        const response = await fetch(
          `${CONFIG.getApiBaseUrl()}/api/pricing/apply`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              recommendation_id: recommendationId,
              applied_by: user.restaurantName
            })
          }
        );
        
        if (!response.ok) throw new Error('Failed to apply recommendation');
        
        const data = await response.json();
        console.log('‚úÖ Recommendation applied:', data);
        
        // Show success message
        alert('‚úÖ Recommendation applied successfully! Impact will be tracked.');
        
        // Reload recommendations
        await loadRecommendations();
        await loadImpactMetrics();
        
      } catch (error) {
        console.error('Error applying recommendation:', error);
        alert('‚ùå Failed to apply recommendation. Please try again.');
      }
    }
    
    // =====================================
    // LOAD IMPACT METRICS
    // =====================================
    
    async function loadImpactMetrics() {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await fetch(
          `${CONFIG.getApiBaseUrl()}/api/pricing/impact/${restaurantId}?period=month`,
          {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          }
        );
        
        if (!response.ok) throw new Error('Failed to load impact metrics');
        
        const data = await response.json();
        console.log('üìà Impact metrics loaded:', data);
        
        // Update UI
        document.getElementById('total-impact').textContent = 
          `¬£${data.summary.total_revenue_impact.toLocaleString()}`;
        document.getElementById('accuracy').textContent = 
          `${data.summary.average_accuracy}%`;
        document.getElementById('applied-count').textContent = 
          data.summary.recommendations_applied;
        
      } catch (error) {
        console.error('Error loading impact metrics:', error);
        // Silent fail - not critical
      }
    }
    
    // =====================================
    // UTILITY FUNCTIONS
    // =====================================
    
    function showError(elementId, message) {
      const element = document.getElementById(elementId);
      if (element) {
        element.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #ef4444;">
            <div style="font-size: 3rem; margin-bottom: 16px;">‚ö†Ô∏è</div>
            <h3>Error</h3>
            <p>${message}</p>
            <button onclick="location.reload()" 
                    style="margin-top: 20px; padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">
              Retry
            </button>
          </div>
        `;
      }
    }
  </script>
</body>
</html>
```

---

## üìã IMPLEMENTATION CHECKLIST

### **Week 1-2: Database & Backend Foundation**
- [ ] Create `demand_snapshots` table
- [ ] Create `pricing_recommendations` table
- [ ] Create `revenue_snapshots` table
- [ ] Create `external_events` table
- [ ] Implement `GET /api/pricing/demand/:restaurantId`
- [ ] Implement demand calculation logic
- [ ] Test with sample data

### **Week 3-4: External Integrations**
- [ ] Sign up for OpenWeather API (free tier)
- [ ] Sign up for Ticketmaster API (free tier)
- [ ] Implement weather data fetching
- [ ] Implement events data fetching
- [ ] Cache external data to reduce API calls
- [ ] Test integrations

### **Week 5-6: Recommendations Engine**
- [ ] Implement `GET /api/pricing/recommendations/:restaurantId`
- [ ] Build recommendation algorithm (v1 - rule-based)
- [ ] Implement `POST /api/pricing/apply`
- [ ] Create impact tracking system
- [ ] Test recommendation accuracy

### **Week 7-8: Frontend Dashboard**
- [ ] Create revenue-optimization.html page
- [ ] Build demand meter widget
- [ ] Build recommendations cards
- [ ] Build forecast chart
- [ ] Build impact tracker
- [ ] Add real-time updates
- [ ] Polish UI/UX

### **Week 9-10: Testing & Refinement**
- [ ] Pilot with 3 test venues
- [ ] Collect feedback
- [ ] Refine algorithm based on results
- [ ] Add automated alerts (email/SMS)
- [ ] Documentation

### **Week 11-12: Launch Preparation**
- [ ] Create marketing materials
- [ ] Set up tiered pricing
- [ ] Build sales presentation
- [ ] Train first customers
- [ ] Launch! üöÄ

---

## üí∞ PRICING TIERS

### **Included in Base Platform** (All venues get)
- Basic demand indicator
- Simple trend analysis
- 3-day forecast

### **Revenue Optimization Premium** (¬£500/month)
- Advanced AI recommendations
- 14-day forecast
- Weather + events integration
- Revenue impact tracking
- Priority support

### **Enterprise** (¬£1000/month)
- Everything in Premium
- Custom pricing models
- Multi-location optimization
- API access
- Dedicated success manager
- White-label option

---

## üéØ SUCCESS METRICS TO TRACK

### **Product Metrics:**
- Recommendation accuracy rate (target: >80%)
- Average revenue impact per venue (target: ¬£2000+/month)
- Recommendations accepted rate (target: >50%)
- Time to first recommendation (target: <24 hours)

### **Business Metrics:**
- Premium tier conversion rate (target: 30%)
- Monthly recurring revenue per venue (target: ¬£500)
- Customer satisfaction (NPS target: >50)
- Churn rate (target: <10%/year)

---

## üöÄ GO-TO-MARKET STRATEGY

### **Phase 1: Pilot (Month 1-2)**
- Launch with 5 hand-picked venues
- Different venue types (restaurant, hotel, stadium)
- Free during pilot in exchange for feedback
- Build case studies

### **Phase 2: Beta (Month 3-4)**
- 20-30 paying customers
- ¬£250/month early adopter pricing
- Refine based on real data
- Collect testimonials

### **Phase 3: General Availability (Month 5+)**
- Full pricing tiers activated
- Scale to 100+ venues
- Automated onboarding
- Self-service sign-up

---

## üìû NEXT STEPS

**Steve, this is your complete blueprint!**

Everything you need is here:
‚úÖ Database schema
‚úÖ API endpoints
‚úÖ Frontend UI
‚úÖ External integrations
‚úÖ Implementation roadmap
‚úÖ Pricing strategy

**Ready to start building?**

Let me know if you want me to:
1. Create the actual SQL migration files
2. Write the complete backend functions
3. Build additional UI mockups
4. Design the marketing materials

**LET'S MAKE THIS HAPPEN!** üöÄüíé

---

**Generated:** November 14, 2025  
**Feature:** Dynamic Pricing & Yield Management  
**Status:** Ready to build  
**Privacy:** 100% safe ‚úÖ